<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>预祝曲乐同学顺利毕业</title>
  
  <subtitle>每天进步一点点</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="xdlequ.github.io/"/>
  <updated>2020-04-07T14:21:28.589Z</updated>
  <id>xdlequ.github.io/</id>
  
  <author>
    <name>曲乐xd_bd</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode刷题</title>
    <link href="xdlequ.github.io/2020/04/07/Leetcode%E5%88%B7%E9%A2%98/"/>
    <id>xdlequ.github.io/2020/04/07/Leetcode%E5%88%B7%E9%A2%98/</id>
    <published>2020-04-07T14:22:24.388Z</published>
    <updated>2020-04-07T14:21:28.589Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Leetcode刷题"><a href="#Leetcode刷题" class="headerlink" title="Leetcode刷题"></a>Leetcode刷题</h1><p>不管是春招还是秋招，校招生是避免不了刷题操作的，今天我总结了一下自己秋招过程对leetcode题目进行分类并针对性练习的过程。<br /><br><br />一些基本的数据结构练习，建议结合大话数据结构这本书食用。里面有一部分语言特性，注意总结与分析，有助于加深数据结构基础的理解。<br /><strong>基本数据结构总结</strong><br />推荐题目：</p><ul><li><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">LeetCode 1. Two Sum</a></li><li><a href="https://leetcode-cn.com/problems/repeated-dna-sequences/" target="_blank" rel="noopener">LeetCode 187. Repeated DNA Sequences</a></li><li><a href="https://leetcode-cn.com/problems/design-hashmap/" target="_blank" rel="noopener">LeetCode 706. Design HashMap</a></li><li><a href="https://leetcode-cn.com/problems/find-duplicate-subtrees/" target="_blank" rel="noopener">LeetCode 652. Find Duplicate Subtrees</a></li><li><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">LeetCode 560. Subarray Sum Equals K</a></li><li><a href="https://leetcode-cn.com/problems/friend-circles/" target="_blank" rel="noopener">LeetCode 547. Friend Circles</a></li><li><a href="https://leetcode-cn.com/problems/redundant-connection/" target="_blank" rel="noopener">LeetCode 684. Redundant Connection</a></li><li><a href="https://leetcode-cn.com/problems/top-k-frequent-words/" target="_blank" rel="noopener">LeetCode 692. Top K Frequent Words</a></li><li><a href="https://leetcode-cn.com/problems/find-median-from-data-stream/" target="_blank" rel="noopener">LeetCode 295. Find Median from Data Stream</a></li><li><a href="https://leetcode-cn.com/problems/data-stream-as-disjoint-intervals/" target="_blank" rel="noopener">LeetCode 352. Data Stream as Disjoint Intervals</a></li></ul><p><br />二分查找一般是在单调有序的数组上操作，而实际的变体却是很灵活的。例如lc287题就是一种经典的应用，关于二分内容，推荐下面几道题目，扣好边界是关键。<br /><strong>二分专题</strong></p><ul><li><a href="https://leetcode-cn.com/problems/sqrtx/" target="_blank" rel="noopener">Leetcode 69. sqrt x</a></li><li><a href="https://leetcode-cn.com/problems/search-insert-position/" target="_blank" rel="noopener">Leetcode 35. Search insert position</a></li><li><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">LeetCode 34. Find First and Last Position of Element in Sorted Array</a></li><li><a href="https://leetcode-cn.com/problems/search-a-2d-matrix/" target="_blank" rel="noopener">LeetCode 74. Search a 2D Matrix</a></li><li><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">LeetCode 153. Find Minimum in Rotated Sorted Array</a></li><li><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">LeetCode 33. Search in Rotated Sorted Array</a></li><li><a href="https://leetcode-cn.com/problems/first-bad-version/" target="_blank" rel="noopener">LeetCode 278. First Bad Version</a></li><li><a href="https://leetcode-cn.com/problems/find-peak-element/" target="_blank" rel="noopener">LeetCode 162. Find Peak Element</a></li><li><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">LeetCode 287. Find the Duplicate Number</a></li><li><a href="https://leetcode-cn.com/problems/h-index-ii/" target="_blank" rel="noopener">LeetCode 275. H-Index II</a></li></ul><p><br />关于链表，考点居多，但是常考的题目固定，校招过程中，遇到的更多的是逆置等问题，这里总结了几道题目，个人建议将链表排序这部分着重复习，例如链表快排，链表插排，链表归并排，都考过，尤其是字节的面试官，非常喜欢考链表的题目，这部分题目，扣好细节即可。<br /><strong>链表专题</strong><br />推荐题目:</p><ul><li><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener"> LeetCode 19. Remove Nth Node From End of List</a></li><li><a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/" target="_blank" rel="noopener">LeetCode 237. Delete Node in a Linked List</a></li><li><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">LeetCode 83. Remove Duplicates from Sorted List</a></li><li><a href="https://leetcode-cn.com/problems/rotate-list/" target="_blank" rel="noopener">LeetCode 61. Rotate List</a></li><li><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">LeetCode 24. Swap Nodes in Pairs</a></li><li><a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">LeetCode 206. Reverse Linked List</a></li><li><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">LeetCode 92. Reverse Linked List II</a></li><li><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">LeetCode 160. Intersection of Two Linked Lists</a></li><li><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">LeetCode 142. Linked List Cycle II</a></li><li><a href="https://leetcode-cn.com/problems/sort-list/" target="_blank" rel="noopener">LeetCode 148. Sort List</a></li></ul><p>树与二叉树同样是字节面试官喜欢考的内容，因为这一部分内容能够很好的验证面试者对递归操作得理解与掌握。内容以二叉树居多，二叉树的几种遍历方法需要烂熟于心（非递归版本）<br /><strong>树专题</strong><br />推荐题目:</p><ul><li><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">LeetCode 98. Validate Binary Search Tree</a></li><li><a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">LeetCode 101. Symmetric Tree</a></li><li><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">LeetCode 94. Binary Tree Inorder Traversal</a></li><li><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">LeetCode 105. Construct Binary Tree from Preorder and Inorder Traversal</a></li><li><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">LeetCode 102. Binary Tree Level Order Traversal</a></li><li><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">LeetCode 236. Lowest Common Ancestor of a Binary Tree</a></li><li><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/" target="_blank" rel="noopener"> LeetCode 297. Serialize and Deserialize Binary Tree</a></li><li><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/" target="_blank" rel="noopener">LeetCode 543. Diameter of Binary Tree</a></li><li><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/" target="_blank" rel="noopener">LeetCode 124. Binary Tree Maximum Path Sum</a></li><li><a href="https://leetcode-cn.com/problems/binary-search-tree-iterator/" target="_blank" rel="noopener">LeetCode 173. Binary Search Tree Iterator</a></li></ul><p>字符串处理是常见题目，这部分不多说，主要空格和逗号，属于一些常规题目，简单推荐几道，可以包含几种常见的类型了<br /><strong>字符串处理</strong><br />推荐题目:</p><ul><li><a href="https://leetcode-cn.com/problems/count-and-say/" target="_blank" rel="noopener">LeetCode 38. Count and Say </a></li><li><a href="https://leetcode-cn.com/problems/group-anagrams/" target="_blank" rel="noopener">LeetCode 49. Group Anagrams </a></li><li><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/" target="_blank" rel="noopener">LeetCode 151. Reverse Words in a String</a></li><li><a href="https://leetcode-cn.com/problems/compare-version-numbers/" target="_blank" rel="noopener">LeetCode 165. Compare Version Numbers </a></li><li><a href="https://leetcode-cn.com/problems/unique-email-addresses/" target="_blank" rel="noopener">LeetCode 929. Unique Email Addresses </a></li><li><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">LeetCode 5. Longest Palindromic Substring</a></li><li><a href="https://leetcode-cn.com/problems/zigzag-conversion/" target="_blank" rel="noopener">LeetCode 6. ZigZag Conversion </a></li><li><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">LeetCode 3. Longest Substring Without Repeating Characters </a></li><li><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/" target="_blank" rel="noopener">LeetCode 208. Implement Trie (Prefix Tree) </a></li><li><a href="https://leetcode-cn.com/problems/integer-to-english-words/" target="_blank" rel="noopener">LeetCode 273. Integer to English Words</a></li></ul><p>从这开始，进入虐心模式，这部分题目我刷了整整两天，刷的清爽的不得了。主要是深度优先搜索与回溯，这部分时间复杂度较大，经常难以找到合适的思路。<br /><strong>回溯法与深度优先搜索</strong><br />推荐题目：</p><ul><li><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">LeetCode 17. Letter Combinations of a Phone Number </a></li><li><a href="https://leetcode-cn.com/problems/word-search/" target="_blank" rel="noopener">LeetCode 79. Word Search </a></li><li><a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">LeetCode 46. Permutations </a></li><li><a href="https://leetcode-cn.com/problems/permutations-ii/" target="_blank" rel="noopener">LeetCode 47. Permutations II </a></li><li><a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">LeetCode 78. Subsets </a></li><li><a href="https://leetcode-cn.com/problems/subsets-ii/" target="_blank" rel="noopener">LeetCode 90. Subsets II </a></li><li><a href="https://leetcode-cn.com/problems/combination-sum-iii/" target="_blank" rel="noopener">LeetCode 216. Combination Sum III </a></li><li><a href="https://leetcode-cn.com/problems/n-queens-ii/" target="_blank" rel="noopener">LeetCode 52. N-Queens II </a></li><li><a href="https://leetcode-cn.com/problems/sudoku-solver/" target="_blank" rel="noopener">LeetCode 37. Sudoku Solver</a></li><li><a href="https://leetcode-cn.com/problems/matchsticks-to-square/" target="_blank" rel="noopener">LeetCode 473. Matchsticks to Square</a></li></ul><p>这部分题目涉及到一些较为复杂的数据结构，<br /><strong>滑动窗口、双指针与单调队列/栈</strong><br />推荐题目：</p><ul><li><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">LeetCode 167. Two Sum II - Input array is sorted </a></li><li><a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank" rel="noopener">LeetCode 88. Merge Sorted Array</a></li><li><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">LeetCode 26. Remove Duplicates from Sorted Array </a></li><li><a href="https://leetcode-cn.com/problems/minimum-window-substring/" target="_blank" rel="noopener">LeetCode 76. Minimum Window Substring </a></li><li><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/" target="_blank" rel="noopener">LeetCode 32. Longest Valid Parentheses </a></li><li><a href="https://leetcode-cn.com/problems/min-stack/" target="_blank" rel="noopener">LeetCode 155. Min Stack </a></li><li><a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">LeetCode 42. Trapping Rain Water </a></li><li><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">LeetCode 84. Largest Rectangle in Histogram </a></li><li><a href="https://leetcode-cn.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">LeetCode 239. Sliding Window Maximum </a></li><li><a href="https://leetcode-cn.com/problems/maximum-sum-circular-subarray/" target="_blank" rel="noopener">LeetCode 918. Maximum Sum Circular Subarray</a></li></ul><p><br />对于我来说，最难的部分，但是学会之后就会很舒服。DP日渐成为各大公司面试的必考点。通过DP可以有效的减少时间复杂度与重复计算。<br /><strong>动态规划</strong><br />推荐题目：</p><ul><li><a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">LeetCode 53. Maximum Subarray </a></li><li><a href="https://leetcode-cn.com/problems/triangle/" target="_blank" rel="noopener">LeetCode 120. Triangle </a></li><li><a href="https://leetcode-cn.com/problems/unique-paths-ii/" target="_blank" rel="noopener">LeetCode 63. Unique Paths II </a></li><li><a href="https://leetcode-cn.com/problems/decode-ways/" target="_blank" rel="noopener">LeetCode 91. Decode Ways </a></li><li><a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">LeetCode 198. House Robber </a></li><li><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">LeetCode 300. Longest Increasing Subsequence </a></li><li><a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">LeetCode 72. Edit Distance </a></li><li><a href="https://leetcode-cn.com/problems/coin-change-2/" target="_blank" rel="noopener">LeetCode 518. Coin Change 2 </a></li><li><a href="https://leetcode-cn.com/problems/strange-printer/" target="_blank" rel="noopener">LeetCode 664. Strange Printer </a></li><li><a href="https://leetcode-cn.com/problems/regular-expression-matching/" target="_blank" rel="noopener">LeetCode 10. Regular Expression Matching</a></li></ul><p>以上，是我刷的部分leetcode题目，偶尔还会打打周赛。另外，剑指offer是必刷的。个人比较推荐牛客网的剑指offer题目。最后，祝各位同学面试顺利，拿到满意的offer<br /></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Leetcode刷题&quot;&gt;&lt;a href=&quot;#Leetcode刷题&quot; class=&quot;headerlink&quot; title=&quot;Leetcode刷题&quot;&gt;&lt;/a&gt;Leetcode刷题&lt;/h1&gt;&lt;p&gt;不管是春招还是秋招，校招生是避免不了刷题操作的，今天我总结了一下自己秋招过程
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>假如我是面试官(一)</title>
    <link href="xdlequ.github.io/2020/04/05/%E5%81%87%E5%A6%82%E6%88%91%E6%98%AF%E9%9D%A2%E8%AF%95%E5%AE%98(%E4%B8%80)/"/>
    <id>xdlequ.github.io/2020/04/05/%E5%81%87%E5%A6%82%E6%88%91%E6%98%AF%E9%9D%A2%E8%AF%95%E5%AE%98(%E4%B8%80)/</id>
    <published>2020-04-05T09:48:57.000Z</published>
    <updated>2020-04-05T09:49:57.922Z</updated>
    
    <content type="html"><![CDATA[<p>又是一年春招之时，在写完论文并提交盲审之后，我又开始了自己的学习总结之路。我想到了一个比较基础的题目（不喜勿喷），如果我是面试官，我一定会从这道问题展开面试。<br />问：请从结合下面一段代码，讲一下你所掌握的Java知识点，多多益善。<br /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo demo=<span class="keyword">new</span> Demo();</span><br><span class="line">        demo.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一段很普通的代码，结合这一普通的问题，我一开始确实想不到啥特殊的内容，但是仔细一想，里面的涉及到的Java基础内容却蛮多的。且听我慢慢道来：<br><a name="oJZCH"></a></p><h2 id="1-Demo命名中的知识点"><a href="#1-Demo命名中的知识点" class="headerlink" title="1. Demo命名中的知识点"></a>1. Demo命名中的知识点</h2><p>一般这个文件，我们会将其命名为Demo.java。一个Java文件中，可以有多个类，但只能有一个public类，并且public的类名必须与文件名一致。关于这一问题，《Think in Java》中有这样几段话：</p><ol><li><strong>每个编译单元（文件）都只能有一个public类，这表示每个编译单元都有单一的公共接口</strong>，用public类来表现。该接口可以按要求包含众多的支持包访问权限的类。如果在某编译单元内有一个以上的public类，编译器就会给出错误信息。（按照我的理解，每个类代表一个对象，在编译过程中，以该对象为主体展开，如果存在多个主体，编译器会报错）</li><li>public类的名称必须完全与含有编译单元的文件名相同，包含大小写，如果不匹配，同样将得到编译错误。（这就是规范问题了，就好像为啥那种生物叫鸡，另外一种生物叫鹅一样）</li><li>虽然不常用，但是编译单元内完全不带public类也是可能的。这种情况下，可以随意对文件命名。</li></ol><p>当java源文件不存在public类时，会出现什么情况呢？<br /><img src="https://user-gold-cdn.xitu.io/2020/4/5/17149a56e5885a50?w=864&h=395&f=png&s=72992" alt="">此时对该程序使用javac的编译命令时（这一过程其实还可以继续深入下去，此处先不展开），编译通过，在相应路径下产生三个.class文件。所以，一个Java文件中可以存在多个类，在编译时，会产生多个不同的.class文件，.class文件便是程序运行的数据来源。Java将public类作为每个编译单元的入口，只能有一个。当一个Java文件有多个非public类时，运行时需要对数据来源进行选择。<br><a name="ZOFJB"></a></p><h2 id="2-javac与java命令"><a href="#2-javac与java命令" class="headerlink" title="2. javac与java命令"></a>2. javac与java命令</h2><p>前面提到了javac命令，通过javac Demo.java文件，可以生成Demo.class字节码文件，直接打开Demo.class字节码文件是一堆乱码，我们无从下手。为了得到Hello world的输出，需要使用java Demo的命令得到输出。通过javap反编译命令，可以得到字节码文件的详细内容。<br /><img src="https://user-gold-cdn.xitu.io/2020/4/5/17149a56e64233d8?w=632&h=445&f=png&s=32850" alt="image.png"><br />这里面的内容就真的值得我们去深入研究学习了。但是目前我功力尚浅，还不能完全解释这些内容，所以不能大胆的去解释，害怕形成误导。需要注意的几点：例如invokespecial，invokevirtual，getstatic等内容需要注意，想要成为一名出色的Java程序员，这些东西是必须要学习的。<strong>javac的编译过程主要涉及jdk中的一些处理操作，这些内容与编译原理高度相关。并未涉及到JVM的相关操作。</strong>在编译之后，得到我们熟悉的字节码文件.class。使用java Demo过程，就是Java面试过程中常问的jvm相关内容。<br /><img src="https://user-gold-cdn.xitu.io/2020/4/5/17149a56e6d20b84?w=537&h=437&f=jpeg&s=63792" alt="21c93540f10a828a65cf74dc3d2ea8a.jpg"><br />在控制台输入java Demo时，会在内存区域创建一个Java虚拟机（JVM），JVM会将上述过程生成的Demo.class文件加载进方法区（1.8之后变为元数据区，放在直接内存中，但是仍然有相关的GC收集器进行管理）进行类加载过程，具体的有加载-&gt;验证-&gt;准备-&gt;解析-&gt;初始化-&gt;使用-&gt;卸载的过程。这部分在周志明老师的书中有专门的一部分进行了详细的解析。<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.md" target="_blank" rel="noopener">类加载过程详解</a><br />几个关键步骤：<br />1.验证：主要验证class文件的版本能不能兼容当前JVM版本，class文件是否满足jvm规范<br /><br><br />2.准备：把类成员初始化为初始值(final的类变量除外)。final变量直接初始化为变量值。<br /><br><br />3.解析：把符号引用解析为直接引用，符号引用就是我们写的xx变量，xxx对应的引用，如Integer xxx=new Integer();<br />解析就是要把类似于xxx这种符号引用变为直接引用即内存地址。<br /><br><br />4.初始化：把我们定义的static变量或者static静态代码块按顺序组织成（即类构造器)来初始化变量。<br /><br><br />这里仅仅涉及到JVM内存的方法区的知识，方法区是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。方法区有时候也被人称为永久代，方法区和永久代的关系很像Java中接口和类的关系，类实现了接口，而永久代是HotSpot虚拟机对虚拟机规范中方法区的一种实现方式。永久代是HotSpot的概念，方法区是Java虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。<br><a name="sozDM"></a></p><h2 id="3-对象的创建"><a href="#3-对象的创建" class="headerlink" title="3.对象的创建"></a>3.对象的创建</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Demo demo = <span class="keyword">new</span> Demo();</span><br></pre></td></tr></table></figure><p>这一句话，有对象创建的过程。new Demo()操作会创建一个对象，demo为一个对象的声明，<strong>对象的声明就是对象的引用指向堆内存中开辟的对象。新创建的对象存储在堆空间里，相关的引用存储在栈(虚拟机栈)中。</strong><br />在上述程序中，首先执行的是main代表的主线程，当执行遇到new关键字时，主线程便在自己的虚拟机栈中声明一个对象hello，在JVM的堆内存中申请一片内存区域，然后将Demo相关的信息，例如实例变量，实例方法等从方法区中加载到堆内存中。<br />对象中比较关键的是头部信息，主要有三部分构成：<br /><br><br />1.MarkWord：主要描述<strong>持有当前对象锁的线程ID和持有对象锁的线程个数</strong>，<strong>在gc中存活的生命周期数</strong>，<strong>偏向锁的标志等</strong><br /><br><br />2.类指针：指向方法区对应类信息的指针。<br /><br><br />3.对齐填充<br /><br><br />这些仅仅是通过几行简短的程序所能扩展出来的知识点。所以不要小看hello world，还是很有意思的。<br />如果在Demo.java文件中加入静态代码块，非静态代码块，继承等机制，难度会增加一个level。所以假如我是面试官，我会通过这一问题，考察你对jvm和java基础的理解程度。<br /></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;又是一年春招之时，在写完论文并提交盲审之后，我又开始了自己的学习总结之路。我想到了一个比较基础的题目（不喜勿喷），如果我是面试官，我一定会从这道问题展开面试。&lt;br /&gt;问：请从结合下面一段代码，讲一下你所掌握的Java知识点，多多益善。&lt;br /&gt;&lt;/p&gt;
&lt;figure
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>校招面经</title>
    <link href="xdlequ.github.io/2020/04/05/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E7%BB%8F/"/>
    <id>xdlequ.github.io/2020/04/05/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E7%BB%8F/</id>
    <published>2020-04-05T02:31:08.156Z</published>
    <updated>2020-04-05T09:47:27.965Z</updated>
    
    <content type="html"><![CDATA[<p>更多的是一些问题，留给还在奋斗的小伙伴们，最近也会逐步的放出自己当时整理的内容。以后可能要往大数据方向发展了，在掘金记录自己技术成长的步伐吧。</p><p><strong>网络中tcp具体的一些问题。</strong></p><p>TCP（必问，需要清晰掌握，简单列举一下）</p><ul><li><p>基本特点，报文头大小与具体结构，序号/确认号作用，控制位及各自含义，可选头的时间戳（简单了解）；</p></li><li><p>面向连接，三握四挥（记清楚），握手的 SYN 洪泛攻击，挥手的 FIN-WAIT-2 以及 TIME-WAIT 状态，两次挥手后的 TCP 半开，四次挥手后的等待，MSL 时间，time-wait 的快速回收，fin-wait-2 的设定时间；</p></li><li><p>TCP 连接能否感知对方是否在线（规范不能，实际可以），TCP 保活机制（SO_KEEPALIVE），保活参数（保活定时，失活前检查参数等），应用层面保活（心跳包，ping/pong 包等））；</p></li><li><p>可靠传输，结合序号/确认号说明，停止并等待 ARQ，结合流水线/滑动窗口的连续 ARQ，超时重传机制，RTT，RTO，差错恢复机制，GBN，SR，快速重传（冗余 ARK）等；<br>流量控制，目的（防止接收方缓存溢出导致分组丢失），基本原理，不足及改进（匹配相差一个 RTT，接单了解一下）；</p></li><li><p>拥塞控制，目的（避免网络拥塞），基本原理，慢启动，拥塞避免，快速回复，快速重传，AIMD（加法增大乘法减小），导致网络通讯波动（同时进入控制状态，时大时小），随机早期检测算法（了解一下）；</p></li><li><p>UDP（可能作为对比来问，无连接，尽力而为，面向报文，无各种控制，一对一，一对多，多对多，首部大小及结构，校验和计算过程（求和，溢出回卷，反码，校验等），可能间插着问问正反补码）；</p></li><li><p>TCP，UDP 伪首部，虚拟的数据结构，参与计算校验和，简单了解；<br>网络层（主机到主机间的逻辑通信）；</p></li><li><p>IP （感觉其实传输层以下问的不多，能说出来就行了。v4/v6，点分十进制，各类地址空间，DNS，NAT，DHCP，路由寻址，EGP（BGP 看一下留个印象），IGP（RIP，OSPF 留个印象））；</p></li><li><p>ICMP（知道类型 0 和类型 8 报文是啥（Echo 响应与请求），ping 的流程）；<br>ARP（地址解析协议，了解一下流程什么的）；</p></li><li><p>MAC（介质访问控制协议，简单了解一下）；</p></li></ul><p><strong>数据库</strong></p><ul><li>关系数据库（实际上主要指 MySQL）</li><li>范式，背下来吧；</li><li>基本 sql 语法（这个我真记的不咋行，因为平时用也都是要查查的）；</li><li>数据结构（B 树，B+ 树，插入分裂，删除合并等，结合 MySQL InnoDB，结合聚簇索引，B+ 树的好处（B+ 树方便遍历，内容在叶子所以效率稳定，IO 吞吐更大开销低））；</li></ul><p><strong>索引</strong></p><ul><li>哈希索引（InnoDB 自适应）；</li><li>聚簇索引/非聚簇索引；</li><li>主键索引/唯一索引/二级索引；</li><li>单列索引/联合索引；</li><li>覆盖索引；</li><li>最左匹配，查询回表等；</li><li>索引优缺点（加快检索速度，加快多表连接，额外空间开销，维护索引的额外时间开销）；</li><li>适合不适合建立索引的字段等；</li><li>索引无法使用的情况（模糊匹配，OR 前后没有同时使用，联合索引的最左匹配等）；</li></ul><p><strong>事务（集中式）</strong></p><ul><li>事务的基本概念，事务的提交，回滚等；ACID特性；</li><li>事务的并发问题（第一二类丢失更新，脏读，不可重复读，幻读）；</li><li>隔离级别（读未提交，读已提交，可重复读，串行化）；</li><li>事务的支持，InnoDB；</li></ul><p><strong>数据库锁</strong></p><ul><li>锁的概念和大类别（悲观并发控制，乐观并发控制，MVCC 等）；</li><li>数据库锁的类别（主要是悲观锁，表锁/叶锁/行锁，意向锁，共享锁/排它锁，更新锁，记录锁/间隙锁/Next-Key锁等）；</li><li>InnoDB，索引加锁，行锁的使用（比较执行代价），行锁死锁（所以行锁复杂），意向锁（解决行表锁冲突），行锁（记录/间隙/Next-Key），更新锁（避免先S后X的死锁）等；</li><li>锁时效性（临时锁，持续锁）；</li><li>加锁协议（一/二/三级加锁协议，二段锁协议（充分条件），一次封锁法等）；</li><li>MVCC 的概念，时间戳版本号，快照版本与当前版本，适用场景等。</li></ul><p><strong>NOSQL（主要指 Redis，本人仅限于有限的使用和了解）</strong></p><ul><li>基本数据类型；</li><li>部分支持事务，单线程（串行，无锁）等；</li><li>淘汰策略（六种，可能挑出来 LRU 问）；</li><li>持久化问题（RDB 快照与 AOF 操作日志）；</li><li>zset 的数据结构（跳表，了解一下）；</li><li>消息队列（不是 Redis 的设计目标）。</li></ul><p><strong>其他问题：</strong></p><ul><li>进程与线程（可以结合语言说）；</li><li>死锁等；</li><li>手撕lru</li><li>正则表达式，简单了解一下；</li><li>设计模式，简单了解一下；</li><li>面向对象概念，特点，原则；</li><li>Linux 的基本使用；</li><li>IO模型（同步/异步，阻塞/非阻塞），BIO，NIO，AIO，IO多路复用等；（epoll详细了解一下）</li><li>Twitter雪花算法（生成分布式ID）；</li><li>海量请求问题，海量数据问题；</li></ul><p><strong>Java</strong></p><ul><li>基础知识，如重载重写，继承多态，关键字等，记清楚；</li><li>Java 数组，容器集合包/类，常用容器，以及相应静态工具包/类，HashMap 底层（红黑树警告），ConcurrentHashMap 原理等（1.8前后变化，分段锁变成 CAS 了）；</li><li>IO/NIO 包，主要结合 IO 模型说（实际上 IO 包已经用 NIO 包重新实现过了）；<br>并发（包），Java 关键字，锁等</li><li>Thread，Runnable，Callable，Future，ThreadLocal 等，会用，知道区别；</li><li>线程池体系，ExecutorService，ScheduledExecutorService 等接口，ThreadPoolExecutor，ForkJoinPool 等实现类，Executors 静态工厂类，线程池的核心参数，几种不同类型的工厂线程池等，会用，了解一下；</li><li>几种常用的阻塞队列，这里很大可能会让写个简单的阻塞队列（生产者消费者），参考下 ArrayBlockingQueue 里面的，用 ReentrantLock 和 Condition 简单写一下就好了；</li><li>几种并发构件，倒计时栅栏，循环栅栏这些，说实话我不常用，简单了解下吧；</li><li>synchronized 关键字，首先知道它是干啥的，其次了解咋实现的，我认为至少要讲到 monitor 面试官才会满意，其间可能牵扯到堆中对象头结构（这里还可能牵扯到数组的 length 属性咋来的），还可能牵扯到锁优化（偏向锁，自旋锁，轻量级锁，锁粗化，锁消除（这里还可能牵扯到对象逃逸等），对象头的 Mark Word 复用等）；</li><li>Lock，主要是 ReentrantLock，要了解 AQS 的基本工作原理，包括同步队列和 Condition 的等待队列等（和 monitor 的队列很像），了解它的 states 状态是用 CAS 算法更新的，了解公平/非公平，了解自旋/挂起；</li><li>了解 CAS 的基本原理，知道 Java 中的 Unsafe 类（知道用这个东西就行了，直接操作内存的，基本用不到）；</li><li>原子类，信号量，了解一下；</li><li>了解经典的进程线程模型（内核线程，轻量级线程，用户线程等），了解 Java 的线程调度策略（抢占式，系统决定），了解 Java 线程优先级（不一一对应，程序不应该依赖于优先级）；</li><li>了解 JMM，了解可见性问题（由此引出 volatile 关键字），知道 volatile 能解决可见性（区别于原子性）和重排序问题，由此引出有序性的先行发生原则（happens-before）。</li><li>JVM 运行时内存区域（虚拟机栈，本地方法栈，程序计数器，堆，方法区（1.8前后变化，永久代被元空间替代了）等，了解栈和堆的区别（小细节：非逃逸对象的栈上分配），了解线程私有区域和共享区域等（比如一个怪问题，布尔值所占的空间大小））；</li><li>垃圾回收算法，引用计数法，可达性分析法（引出强软弱虚四种引用），两次标记（引出 finalize 方法），标记清除（碎片，CMS），标记复制（Eden，Survivor，分配担保，新生代），标记整理（老年代），分代，GC 停顿，Stop The World，安全点/区域等；</li><li>垃圾回收器（七个，记一下特点）；</li><li>JVM 对象分配回收策略（Eden 优先，大对象直接进老年代，长期存活进老年代，动态年龄判定等）；</li><li>类加载器（Bootstrap，Extension，Application 以及自定义的），双亲委派（能否破坏，loadClass 方法），加载流程（加载，验证，准备，解析，初始化），加载时候生成方法区对应的类的数据结构，以及生成对应的 class 对象（小细节问题：数组没有对应的类，怎么生成的），准备过程（分配类变量空间，赋值后延到初始化），初始化过程（结合 Java 新建对象各部分执行顺序分析）；</li><li>class 对象引出反射，引出代理（Java 代理和 CGLib，了解一下）；</li><li>框架（主要指 Spring）了解一下，IOC 和 AOP 的概念与原理，感觉框架问的并不多（实际上 Java 问的就很少）。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;更多的是一些问题，留给还在奋斗的小伙伴们，最近也会逐步的放出自己当时整理的内容。以后可能要往大数据方向发展了，在掘金记录自己技术成长的步伐吧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;网络中tcp具体的一些问题。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;TCP（必问，需要清晰掌握，简单列举一
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
